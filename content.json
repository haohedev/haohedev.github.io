[{"title":"基于SRS的流媒体服务器在安防行业的集成应用","date":"2018-11-11T01:44:45.000Z","path":"video-surveillance-system/","excerpt":"背景在给企业或者政府做安全生产相关的系统时，都绕不开视频监控这一重要环节，而通常涉及到的企业会有大量的摄像头或者硬盘录像机（DVR）等设备。在日益趋向BS架构的应用，如何可以在现代浏览器里播放这些摄像头呢？ 思路在互联网点播技术非常盛行的今天，有着各种各样的优秀方案，不乏一些高质量的开源框架如：SRS、Nginx+RTMP等。我们今天就来聊聊SRS这个优秀的框架。本文将提供一个思路以及带领大家动手实现一个简单的示例。更多的细节参见官方的WIKI。 前提 本文的SRS将在docker中运行，所以必须有一个可以运行docker的系统。本文是在ubuntu 18.04下采用docker中运行。 身边有一个硬盘录像机(DVR)或网络摄像机（IPC），本文采用的是海康DVR。 自行安装ffmpeg，本文将采用ffmpeg对视频流进行转码。","categories":[{"name":"Video","slug":"Video","permalink":"http://zyzz.xyz/categories/Video/"}],"tags":[]},{"title":"Ogre+WebUI(基于QWebView的实现)","date":"2018-07-20T01:08:39.000Z","path":"ogre-webview/","excerpt":"背景公司有自主研发的基于OGRE的三维引擎，同时引擎封装了python2的脚本，现想将三维引擎进一步封装成平台。考虑到前端框架更多，效果丰富，开发周期更短等优势，打算利用WebUI进行界面的开发，三维平台提供API接口供前端调用。 WebUI概念WebUI是指在QMainWindow中设置个渲染OGRE的QWidget，同时创建个透明背景的QWebView覆盖在OGRE窗口上方。因为设置了透明背景，因此页面中透明的部分可以直接看到OGRE窗口。设置WA_TransparentForMouseEvents属性，使得在透明的部分鼠标事件穿过页面直接送达给OGRE窗口。","categories":[],"tags":[{"name":"QT","slug":"QT","permalink":"http://zyzz.xyz/tags/QT/"},{"name":"OGRE","slug":"OGRE","permalink":"http://zyzz.xyz/tags/OGRE/"}]},{"title":"Elasticsearch中文汉字拼音混合搜索","date":"2018-06-19T01:32:58.000Z","path":"elasticsearch-hybrid-search/","excerpt":"背景因为在工作上用到了Elasticsearch搜索，需求中包含中文+拼音混合搜索，在网上看到了Elasticsearch高级搜索排序（ 中文+拼音+首字母+简繁转换+特殊符号过滤）这篇文章，提供了思路。但是该文章使用的应该是Elasticsearch 2.X版本，因此本文同样采用该思路，但是利用Elasticsearch 5.6.3 + JavaScript API的方案来简易实现一版。Elasticsearch 5.X和Elasticsearch 6.X版本，在本文中差异不大，因此都可以使用。 Elasticsearch插件安装插件肯定是最先开始的工作，这里用到了IK分词器和Pinyin分词器，需要选择与Elasticseach对应的版本。 这里提供一个Dockerfile文件，生成基于Elasticsearch 5.6.3版本的镜像并且包含了IK分词器和Pinyin分词器：1234567891011FROM elasticsearch:5.6.3-alpineENV VERSION=5.6.3ADD https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v$&#123;VERSION&#125;/elasticsearch-analysis-ik-$VERSION.zip /tmp/RUN /usr/share/elasticsearch/bin/elasticsearch-plugin install file:///tmp/elasticsearch-analysis-ik-$VERSION.zipADD https://github.com/medcl/elasticsearch-analysis-pinyin/releases/download/v$&#123;VERSION&#125;/elasticsearch-analysis-pinyin-$VERSION.zip /tmp/RUN /usr/share/elasticsearch/bin/elasticsearch-plugin install file:///tmp/elasticsearch-analysis-pinyin-$VERSION.zipRUN rm -rf /tm/*","categories":[{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"http://zyzz.xyz/categories/Elasticsearch/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://zyzz.xyz/tags/JavaScript/"}]},{"title":"基于LiveQuery的数据主动推送","date":"2018-06-15T12:11:44.000Z","path":"live-query-redis/","excerpt":"背景我们知道，当配置了需要推送的类名称之后，通过Parse Server平台更改数据时，会将数据通知到LiveQuery Server, LiveQuery Server通过WebSocket协议对数据进行推送。Parse提供了各个平台相应的SDK，具体的实现可以参考官方网站。基础架构如下图所示： 通常来说，ParseServer和Parse LiveQuery Server是运行在同一个服务中的。","categories":[{"name":"Parse","slug":"Parse","permalink":"http://zyzz.xyz/categories/Parse/"}],"tags":[{"name":"node","slug":"node","permalink":"http://zyzz.xyz/tags/node/"},{"name":"redis","slug":"redis","permalink":"http://zyzz.xyz/tags/redis/"},{"name":"LiveQuery","slug":"LiveQuery","permalink":"http://zyzz.xyz/tags/LiveQuery/"}]},{"title":"ramda-cookbook","date":"2018-06-15T04:57:06.000Z","path":"ramda-cookbook/","excerpt":"背景在学习函数式编程的时候，无意中看到了JS 函数式编程指南，使得对函数式编程的概念有了初步的认识。恰巧当前工作的重心在node这块开发，在学习ES6语法的同时，也强迫自己用函数式编程的思路去写代码。工欲善其事必先利其器，选择一个优秀的库，就等于迈向了成功的大门。在看了很多评价lodash、underscore、ramda的文章之后，感觉被ramda的pointfree的风格吸引住了，很庆幸，有先驱者为ramda库的一系列文章做了翻译，使得更容易理解ramda的设计初衷与使用姿势。正是因为这一些列的文章，让我对函数式编程有了更高层的认识，犹如醍醐灌顶、豁然开朗。虽然没有选择lodash和underscore, 但一有时间我一定会去阅读他们的文档，理解设计理念。同时也建议像我一样初学JavaScript的同学，多利用现有开源库会让你事半功倍，写出更健壮的代码。 初衷在工作中因为经常用到ramda库，会对常用的一些方法进行封装。在看到ramda cookbook的时候，犹如发现了宝藏一般，里面的内容覆盖了大部分常用的函数。通过看其实现的代码，对ramda的一些函数有了更深的理解。 虽然ramda cookbook中的函数比较全，但有时仍不免要自己实现一些特定需求的函数，因此才有了这篇文章。 本篇文章会随着需求的增加不定时更新。","categories":[{"name":"FunctionalPrograming","slug":"FunctionalPrograming","permalink":"http://zyzz.xyz/categories/FunctionalPrograming/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://zyzz.xyz/tags/JavaScript/"}]},{"title":"async-await 陷阱","date":"2018-06-15T01:54:10.000Z","path":"async-await/","excerpt":"在使用async / await时可能会犯什么错误？这里总结了一些常见的问题。 过于串行化虽然await可以让你的代码看起来像同步，但请记住它们仍然是异步的，必须小心避免过于串行化。 12345678async getBooksAndAuthor(authorId) &#123; const books = await bookModel.fetchAll(); const author = await authorModel.fetch(authorId); return &#123; author, books: books.filter(book =&gt; book.authorId === authorId), &#125;;&#125; 上面的代码虽然在逻辑上看起来正确。但还是存在问题的。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://zyzz.xyz/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://zyzz.xyz/tags/JavaScript/"}]}]